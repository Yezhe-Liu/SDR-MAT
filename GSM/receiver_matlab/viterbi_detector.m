function [ rx_burst ] = viterbi_detector(SYMBOLS,NEXT,PREVIOUS,START,STOPS,Y,Rhh)
%
% VITERBI_DETECTOR:
%           This matlab code does the actual detection of the
%           received sequence. As indicated by the name the algorithm
%           is the viterbi algorithm, which is a MLSE. At this time 
%           the approch is to use Ungerboecks modified algorithm, and
%           to return hard output only.
%
% SYNTAX:   [ rx_burst ] 
%           = 
%           viterbi_detector(SYMBOLS,NEXT,PREVIOUS,START,STOPS,Y,Rhh)
%
% INPUT:    SYMBOLS:  The table of symbols corresponding the the state-
%                     numbers. Format as made by make_symbols.m
%           NEXT:     A transition table containing the next legal
%                     states, as it is generated by the code make_next.m
%           PREVIOUS: The transition table describing the legal previous
%		      states as generated by make_previous.m
%           START:    The start state of the algorithm.
%           STOPS:    The legal stop states.
%           Y:        Complex baseband representation of the matched 
%                     filtered and down converted received signal, as it
%                     is returned by mf.m
%           Rhh:      The autocorrelation as estimated by mf.m
%
% OUTPUT:   rx_burst: The most likely sequence of symbols.
%
% SUB_FUNC: make_increment
%
% WARNINGS: None.
%
% TEST(S):  Tested with no noise, perfect syncronization, and channel 
%           estimation/filtering. (Refer to viterbi_ill.m)
%
% AUTOR:    Jan H. Mikkelsen / Arne Norre Ekstrøm
% EMAIL:    hmi@kom.auc.dk / aneks@kom.auc.dk
%
% $Id: viterbi_detector.m,v 1.7 1997/11/18 12:41:26 aneks Exp $

% knowledge of Lh and M is needed for the algorithm to operate
%
[ M , Lh ] = size(SYMBOLS);

% the number of steps in the viterbi
%
STEPS=length(Y);

% initialize tables (this yields a slight speedup).
%
METRIC = zeros(M,STEPS);
SURVIVOR = zeros(M,STEPS);

% determine precalculatable part of metric
%
INCREMENT=make_increment(SYMBOLS,NEXT,Rhh);

% the first thing to do is to roll into the algorithm by spreading out 
% from 	the start state to all the legal states. 
%
PS=START;

% note that the start state is referred to as state to time 0
% and that it has no metric.
%
S=NEXT(START,1);
METRIC(S,1)=real(conj(SYMBOLS(S,1))*Y(1))-INCREMENT(PS,S);
SURVIVOR(S,1)=START;

S=NEXT(START,2);
METRIC(S,1)=real(conj(SYMBOLS(S,1))*Y(1))-INCREMENT(PS,S);
SURVIVOR(S,1)=START;

PREVIOUS_STATES=NEXT(START,:);

% mark the next states as real. n.b: complex indicates the polarity
% of the next state, e.g. state 2 is real.
%
COMPLEX=0;

for N = 2:Lh,
  if COMPLEX,
    COMPLEX=0;
  else
    COMPLEX=1;
  end
  STATE_CNTR=0;
  for PS = PREVIOUS_STATES,
    STATE_CNTR=STATE_CNTR+1;
    S=NEXT(PS,1);
    METRIC(S,N)=METRIC(PS,N-1)+real(conj(SYMBOLS(S,1))*Y(N))-INCREMENT(PS,S);
    SURVIVOR(S,N)=PS;
    USED(STATE_CNTR)=S;
    STATE_CNTR=STATE_CNTR+1;
    S=NEXT(PS,2);
    METRIC(S,N)=METRIC(PS,N-1)+real(conj(SYMBOLS(S,1))*Y(N))-INCREMENT(PS,S);
    SURVIVOR(S,N)=PS;    
    USED(STATE_CNTR)=S;
  end
  PREVIOUS_STATES=USED;
end
% at any rate we will have processed lh states at this time
%
PROCESSED=Lh;

% we want an equal number of states to be remaining. the next lines ensure
% this.
%

if ~COMPLEX,
  COMPLEX=1;
  PROCESSED=PROCESSED+1;
  N=PROCESSED;
  for S = 2:2:M,
    PS=PREVIOUS(S,1);
    M1=METRIC(PS,N-1)+real(conj(SYMBOLS(S,1))*Y(N)-INCREMENT(PS,S));
    PS=PREVIOUS(S,2);
    M2=METRIC(PS,N-1)+real(conj(SYMBOLS(S,1))*Y(N)-INCREMENT(PS,S)); 
    if M1 > M2,
      METRIC(S,N)=M1;
      SURVIVOR(S,N)=PREVIOUS(S,1);
    else
      METRIC(S,N)=M2;
      SURVIVOR(S,N)=PREVIOUS(S,2);
    end
  end
end

% now that we have made the run-in the rest of the metrics are
% calculated in the straight forward manner. observe that only
% the relevant states are calculated, that is real follows complex
% and vice versa.
%
N=PROCESSED+1;
while N <= STEPS,
  for S = 1:2:M-1,
    PS=PREVIOUS(S,1);
    M1=METRIC(PS,N-1)+real(conj(SYMBOLS(S,1))*Y(N)-INCREMENT(PS,S));
    PS=PREVIOUS(S,2);
    M2=METRIC(PS,N-1)+real(conj(SYMBOLS(S,1))*Y(N)-INCREMENT(PS,S)); 
    if M1 > M2,
      METRIC(S,N)=M1;
      SURVIVOR(S,N)=PREVIOUS(S,1);
    else
      METRIC(S,N)=M2;
      SURVIVOR(S,N)=PREVIOUS(S,2);
    end   
  end
  N=N+1;
  for S = 2:2:M,
    PS=PREVIOUS(S,1);
    M1=METRIC(PS,N-1)+real(conj(SYMBOLS(S,1))*Y(N)-INCREMENT(PS,S));
    PS=PREVIOUS(S,2);
    M2=METRIC(PS,N-1)+real(conj(SYMBOLS(S,1))*Y(N)-INCREMENT(PS,S)); 
    if M1 > M2,
      METRIC(S,N)=M1;
      SURVIVOR(S,N)=PREVIOUS(S,1);
    else
      METRIC(S,N)=M2;
      SURVIVOR(S,N)=PREVIOUS(S,2);
    end   
  end
  N=N+1;
end  


% having calculated the metrics, the most probable statesequence is
% initialized by choosing the highest metric among the legal stop 
% states.
%
BEST_LEGAL=0;
for FINAL = STOPS,
  if METRIC(FINAL,STEPS) > BEST_LEGAL,
    S=FINAL;
    BEST_LEGAL=METRIC(FINAL,STEPS);
  end
end

% uncomment for test of metric
%
% METRIC
% BEST_LEGAL
% S
% pause

% having found the final state, the msk symbol sequence is established
%
IEST(STEPS)=SYMBOLS(S,1);
N=STEPS-1;
while N > 0,
  S=SURVIVOR(S,N+1);
  IEST(N)=SYMBOLS(S,1);
  N=N-1;
end

% the estimate is now found from the formula:
% IEST(n)=j*rx_burst(n)*rx_burst(n-1)*IEST(n-1)
% THE FORMULA IS REWRITTEN AS:
% rx_burst(n)=IEST(n)/(j*rx_burst(n-1)*IEST(n-1))
% FOR INITIALIZATION THE FOLLOWING IS USED:
% IEST(0)=1 og rx_burst(0)=1
%
rx_burst(1)=IEST(1)/(j*1*1);
for n = 2:STEPS,
  rx_burst(n)=IEST(n)/(j*rx_burst(n-1)*IEST(n-1));
end

% rx_burst IS POLAR (-1 AND 1), THIS TRANSFORMS IT TO
% BINARY FORM (0 AND 1).
%
rx_burst=(rx_burst+1)./2;